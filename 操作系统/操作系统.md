

```
处理机：计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。
处理机包括中央处理器，主存储器, I/O 接口。处理机再加上外围设备eg:鼠标？键盘？等构成完整的计算机系统。
```



计算机资源主要分为四类
处理机，储存器，i/o设备，以及文件

操作系统分类

* 多批道处理系统
* 分时系统
* 事实系统

基本特征
并发与并行

并行:两个和多个事件同一时间发生
并发:两个或者多个在同一时间间隔内发生



进程是可拥有资源的独立单位

进程与程序是两个截然不同的概念

进程由程序段，相关数据段，和PCB三部分组成

进程具有动态性，并发性，独立性，异步性

进程有三种基本状态
（1）就绪状态

（2）执行状态

（3）阻塞状态



进程控制块的基本信息

（1）进程标识符

（2）处理机状态

​    ① 通用寄存器

​    ② 指令寄存器
​    ③ 程序状态字
​    ④ 用户栈指针

（3）进程调度信息 

   ①  进程状态

   ② 进程优先级

（4）进程控制信息

控制进程快的组织方式
（1）线性方式
（2）链接方式
（3）索引方式

操作系统内核两大重要功能

**支撑功能**
（1）中断处理
（2）时钟管理
（3）原语操作
**资源管理功能**
（1）进程管理
（2）存储器管理
（3）设备管理



引起进程创建的事件
（1）用户登陆
（2）作业调度
（3）提供服务
（4）应用请求

**进程的创建**

（1）申请空白的PCB
（2）为新进程分配其运行的所需的资源
（3）初始化进程控制块 PCB
（4）如果就绪队列能容纳新进程就，便将新进程插入就绪队列

**进程的终止**
（1）正常结束
（2）异常结束
（3）外界干预
进程的阻塞与唤醒
（1）向系统请求共享资源失败
（2）等待某种操作完成
（3）新数据尚未到达
（4）等待新任务的到达



## 进程管理

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620171624.png)



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620172555.png)



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620172749.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620172839.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620174218.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620173109.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620173316.png)

进程的定义

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620173429.png)

![1592645720076](../img/1592645720076.png)



### 进程与程序的比较

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620173629.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620173802.png)

### 进程特征

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620173853.png)

### 进程的状态



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620174722.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620175229.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620175246.png)

### 进程的状态变迁

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620175434.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620180841.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620182156.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620182538.png)



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620182930.png)



### 进程控制块



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620185215.png)

中断之后再执行既是将 pcb的数据载入相应的寄存器

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620185712.png)

pcb 是系统感知进程的存在进行控制的唯一标志

### PCB的内容

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620190604.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620191047.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620191117.png)

### PCB的组织

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620191356.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620191540.png)

![1592651800609](../img/1592651800609.png)



### 进程控制原语



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620212630.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620212822.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620212907.png)

进程创建

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620213919.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620213856.png)



进程终止

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620214309.png)





![](https://gitee.com/muyinchuan/images/raw/master/img/20200620214358.png)



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620214412.png)

![1592660668730](../img/1592660668730.png)



![](https://gitee.com/muyinchuan/images/raw/master/img/20200620214438.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620214758.png)

### **进程同步**

![](https://gitee.com/muyinchuan/images/raw/master/img/20200620215203.png)

![1593191043061](../img/1593191043061.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627010410.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627010518.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627010602.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627010743.png)

### 生产者与消费者问题

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627010800.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627010839.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627010920.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011009.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011123.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011136.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011205.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011226.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011300.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011517.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627011613.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627012353.png)

### 信号量机制

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627014543.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627014819.png)





![](https://gitee.com/muyinchuan/images/raw/master/img/20200627015813.png)

![](https://gitee.com/muyinchuan/images/raw/master/img/20200627015846.png)

以一个停车场的运作为例。简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入外面的一辆进去，如果又离开两辆，则又可以放入两辆，如此往复。

在这个停车场系统中，车位是公共资源，每辆车好比一个[线程](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B)，看门人起的就是信号量的作用。



信号量起到了一个临界区管理的作用 

临界资源是一段时间只允许一个程序访问的资源

访问临界资源的代码叫临界区 如已经访问了打印机，别的机器就不能访问，不然会出现打印错误（硬件临界资源）

![1593697132878](../img/1593697132878.png)

S在这里是表示资源数目，如果打印机是空闲的，就会执行下一操作，即执行打印
在这里P操作（wite(S)）执行完之后程序让出打印机资源就会加一

这个场景让我想起了上厕所，人就好比进程，处于等待厕所与排除废物  两种状态
这样让我想到了一个国家可以类比电脑操作系统，绝妙

**记录信号量**

让权等待 当进程不能进入临界区，应该立即释放处理机，防止进程忙等待。

![1593697958294](../img/1593697958294.png)

![1593698034351](../img/1593698034351.png)

直接减1,S<0，进程就进入缓存区等待资源，处于堵塞状态

![1593698156286](../img/1593698156286.png)

j结束了就释放资源，让给下一位



AND信号量

![1593698217703](../img/1593698217703.png)



AND同步机制将进程需要的所有资源一次性的分配给进程，等他使用完了再释放
场景：扫描机扫描——》打印机打印
一个进程一下两个都拥有了，就等他用完

就好比上厕所坑位和卫生纸都在他那里，你想用卫生纸擦嘴都不行

上面的进程A B 就是

都想使用打印机与扫描器，但是由于顺序不一样，使得两个资源都被用了

但进程又没有结束，导致A 结束打印后等待扫描（但是他是进程没释放打印机）
B同理，两个就都阻塞了，发生死锁

而AND信号量就很好的处理了，就是两个一起分，两个一起释放，就不会导致同一时刻A用打印机 B用扫描仪

![1593699025550](../img/1593699025550.png)



只要有一个资源处于忙碌状态，进程就不会开始

同个进程对同个资源的访问

![1593699168422](../img/1593699168422.png)

信号量集机制

![1593699233765](../img/1593699233765.png)

![1593699278766](../img/1593699278766.png)

如果一次性需要多个同类资源，比如需要多台打印机同时运行，引入这个信号量集再一次原语将所有资源进行分配

Swait(S1, t1 ,d1)

t1是资源分配下限，低于这个量就不会分配资源给进程

信号量大于低于进程需要的量d1就不会分配

分配后Si=Si - di

![1593700008340](../img/1593700008340.png)



还有几个特殊状态

![1593700157996](../img/1593700157996.png)

![1593700248461](../img/1593700248461.png)



![1593700485452](../img/1593700485452.png)



s 开始   F 结束

![1593700655629](../img/1593700655629.png)

![1593700701955](../img/1593700701955.png)



![1593700789557](../img/1593700789557.png)

一个是表示前面是否执行完成，一个是后面的是否能开始



第一类是是否能开始，直接对其释放（或者应该说加一个资源，s+1），后面的就能直接开始



![1593701019261](../img/1593701019261.png)

![1593701085515](../img/1593701085515.png)



理解这相当与把后驱的进程当作临界资源

![1593701280637](../img/1593701280637.png)

生产者，消费者问题

![1593701476893](../img/1593701476893.png)

2-3-3
![1593701498605](../img/1593701498605.png)



管程机制

解决生产者-消费者问题

![1593701754739](../img/1593701754739.png)

![1593701783533](../img/1593701783533.png)

![1593701809661](../img/1593701809661.png)

![1593701822515](../img/1593701822515.png)



![1593701838235](../img/1593701838235.png)

![1593701856298](../img/1593701856298.png)

![1593701868900](../img/1593701868900.png)



![1593701915477](../img/1593701915477.png)

![1593701928404](../img/1593701928404.png)

![1593701941252](../img/1593701941252.png)



### **进程通信  IPC**

![1593701991645](../img/1593701991645.png)

![1593702052771](../img/1593702052771.png)

windows进程通信：管道，套接字，剪贴板

![1593702126852](../img/1593702126852.png)

![1593702135258](../img/1593702135258.png)

![1593702140402](../img/1593702140402.png)

![1593702162573](../img/1593702162573.png)

![1593702217052](../img/1593702217052.png)

![1593702301404](../img/1593702301404.png)

![1593702316707](../img/1593702316707.png)

![1593702328499](../img/1593702328499.png)

![1593702340531](../img/1593702340531.png)

**消息就是有格式的信息**
![1593702366372](../img/1593702366372.png)

![1593702398324](../img/1593702398324.png)

![1593702419540](../img/1593702419540.png)

![1593702429620](../img/1593702429620.png)



![1593702442035](../img/1593702442035.png)

线程运行的三个状态

执行 就绪 与阻塞

线程控制块 TCB

### 什么是线程？
   线程是一个程序内部的顺序控制流。线程本身不能运行，它只能用于程序中，只能使用分配给程序的资源和环境。

线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位,可以看成是轻量级的进程

什么是多线程？
       多线程则指的是在单个程序中可以同时运行多个不同的线程执行不同的任务。

处理机调度 与死锁

![1593702542763](../img/1593702542763.png)

![1593702561643](../img/1593702561643.png)

![1593702586420](../img/1593702586420.png)

![1593702621124](../img/1593702621124.png)

![1593702638436](../img/1593702638436.png)





![1593702659747](../img/1593702659747.png)



![1593702707739](../img/1593702707739.png)

![1593702802836](../img/1593702802836.png)

![1593702820300](../img/1593702820300.png)

2![1593702842739](../img/1593702842739.png)

![1593703177259](../img/1593703177259.png)







![1593703236124](../img/1593703236124.png)

![1593703263715](../img/1593703263715.png)

![1593703357204](../img/1593703357204.png)

![1593703370306](../img/1593703370306.png)

![1593703451946](../img/1593703451946.png)

![1593703465569](../img/1593703465569.png)

![1593703492234](../img/1593703492234.png)web服务进程

![1593703548277](../img/1593703548277.png)

### 处理机调度与死锁

![1593703799372](../img/1593703799372.png)

![1593703831130](../img/1593703831130.png)

![1593703843675](../img/1593703843675.png)



![1593703902484](../img/1593703902484.png)

![1593703928124](../img/1593703928124.png)

![1593703953332](../img/1593703953332.png)

![1593703988554](../img/1593703988554.png)

CPU利用率高

![1593704853945](../img/1593704853945.png)



![1593704873721](../img/1593704873721.png)

![1593705206473](../img/1593705206473.png)

![1593705241537](../img/1593705241537.png)

### 调度服务

####  *周转时间*=作业完成时刻—作业到达时刻

带权周转时间=周转时间/服务时间；

平均周转时间=作业周转总时间/作业个数；

平均带权周转时间=带权周转总时间/作业个数；


  ![1593705661571](../img/1593705661571.png)

![1593705969313](../img/1593705969313.png)

 

![1593706020480](../img/1593706020480.png)

![1593706055945](../img/1593706055945.png)

![1593706072408](../img/1593706072408.png)

![1593706080024](../img/1593706080024.png)

![1593706095249](../img/1593706095249.png)

![1593706144138](../img/1593706144138.png)

![1593706166248](../img/1593706166248.png)

根据一个动态的值区响应

![1593706232096](../img/1593706232096.png)

![1593706251063](../img/1593706251063.png)

![1593706297417](../img/1593706297417.png)



### HRRN

比是先来先服务与短作业优先服务的一种折中算法

第一个作业完成后求响应比 ，第二个作业完成后继续求响应比

![1593707093047](../img/1593707093047.png)

![1593707107206](../img/1593707107206.png)

![1593707121928](../img/1593707121928.png)

![1593707152827](../img/1593707152827.png)

![1593707242992](../img/1593707242992.png)

![1593707461801](../img/1593707461801.png)

![1593707493863](../img/1593707493863.png)

![1593707557839](../img/1593707557839.png)

![1593707632720](../img/1593707632720.png)

![1593707647400](../img/1593707647400.png)

### RP时间片调度算法
![1593707905969](../img/1593707905969.png)

UNIX系统中，进程调度采用的技术是（ ）

动态优先数 

### 这里点问题 



环路也不是很懂

### 实时调度

![1593708647219](../img/1593708647219.png)

![1593708709743](../img/1593708709743.png)

![1593708717472](../img/1593708717472.png)

![1593708726783](../img/1593708726783.png)

![1593708738287](../img/1593708738287.png)

### 死锁的基本概念

![1593708862656](../img/1593708862656.png)

![1593708891327](../img/1593708891327.png)

![1593708936191](../img/1593708936191.png)

![1593708953061](../img/1593708953061.png)

 ![1593708986870](../img/1593708986870.png)

![1593709011215](../img/1593709011215.png)

![1593709023398](../img/1593709023398.png)

![1593709043405](../img/1593709043405.png)

![1593709056800](../img/1593709056800.png)

![1593709065997](../img/1593709065997.png)2

![1593709075679](../img/1593709075679.png)

### 死锁的预防

![1593709140464](../img/1593709140464.png)

打印机是互斥的

![1593709226608](../img/1593709226608.png)

![1593709302103](../img/1593709302103.png)

![1593709311990](../img/1593709311990.png)

![1593709319085](../img/1593709319085.png)

![1593709369903](../img/1593709369903.png)

![1593709378559](../img/1593709378559.png)

![1593709399495](../img/1593709399495.png)

死锁避免

找到一个顺序保证所有进程都拥有足够资源

![1593709680526](../img/1593709680526.png)

### 银行家算法

![1593709780464](../img/1593709780464.png)

![1593709792750](../img/1593709792750.png)

![1593709810269](../img/1593709810269.png)

![1593709825511](../img/1593709825511.png)

![1593709855046](../img/1593709855046.png)

![1593709943310](../img/1593709943310.png)

![1593709990953](../img/1593709990953.png)

### 安全性检测

![1593710094485](../img/1593710094485.png)

死锁检测与解除

![1593710270806](../img/1593710270806.png)

![1593710332046](../img/1593710332046.png)

#### 死锁解除方法

![1593710400238](../img/1593710400238.png)

![1593710416151](../img/1593710416151.png)

![1593710445070](../img/1593710445070.png)

![1593710507421](../img/1593710507421.png)

![1593710519348](../img/1593710519348.png)

![1593710595400](../img/1593710595400.png)

不可化简就是死锁

![1593710718509](../img/1593710718509.png)

![1593710999032](../img/1593710999032.png)

通常不采用(   从非死锁进程处抢夺资源   )方法来解除死锁。

### 存储器管理概述

![1593711289077](../img/1593711289077.png)

![1593711354844](../img/1593711354844.png)

![1593711395413](../img/1593711395413.png)

![1593711402054](../img/1593711402054.png)

![1593711407725](../img/1593711407725.png)

![1593711417829](../img/1593711417829.png)

![1593711438839](../img/1593711438839.png)

![1593711446684](../img/1593711446684.png)

![1593711627717](../img/1593711627717.png)

![1593711638149](../img/1593711638149.png)

![1593711646358](../img/1593711646358.png)

![1593711659173](../img/1593711659173.png)

![1593711745094](../img/1593711745094.png)

![1593711888534](../img/1593711888534.png)

存储管理的目的是（    ）。、

方便用户和提高内存利用率

若处理器有32位地址，则它的虚拟地址空间为（  4GB  ）字节

### 程序的装入与链接

![1593712080525](../img/1593712080525.png)

![1593712146333](../img/1593712146333.png)

![1593712156349](../img/1593712156349.png)

![1593712318053](../img/1593712318053.png)

![1593712333108](../img/1593712333108.png)

![1593712339851](../img/1593712339851.png)

、

![1593712382004](../img/1593712382004.png)

![1593712476892](../img/1593712476892.png)

### 连续分配方式

![1593712630446](../img/1593712630446.png)

![1593712640100](../img/1593712640100.png)

![1593712646812](../img/1593712646812.png)

![1593712812597](../img/1593712812597.png)

#### 动态分区分配

![1593712915044](../img/1593712915044.png)

解决了固定分区的浪费问题



![1593712972332](../img/1593712972332.png)

![1593712991127](../img/1593712991127.png)

![1593713059987](../img/1593713059987.png)

分区释放
![1593713100294](../img/1593713100294.png)

![1593713215813](../img/1593713215813.png)



![1593713210644](../img/1593713210644.png)

![1593713230749](../img/1593713230749.png)

#### 空闲分区

![1593713253054](../img/1593713253054.png)

![1593713294477](../img/1593713294477.png)

#### FF&NF
![1593713306692](../img/1593713306692.png)

![1593713332800](../img/1593713332800.png)

![1593713347869](../img/1593713347869.png)

![1593713379188](../img/1593713379188.png)

![1593713447324](../img/1593713447324.png)

#### BF

![1593713491859](../img/1593713491859.png)

![1593713500118](../img/1593713500118.png)

![1593713548574](../img/1593713548574.png)

![1593713569092](../img/1593713569092.png)

![1593713614461](../img/1593713614461.png)

#### 三种算法形成的队列

![1593713720034](../img/1593713720034.png)

![1593713892789](../img/1593713892789.png)

#### 碎片问题

固定分区会产生碎片

![1593714007827](../img/1593714007827.png)

![1593714039436](../img/1593714039436.png)

![1593714069980](../img/1593714069980.png)

### 分页技术

![1593714208044](../img/1593714208044.png)

![1593714251606](../img/1593714251606.png)

![1593714274405](../img/1593714274405.png)

![1593714326012](../img/1593714326012.png)

每一页大小可以有4K

可以拥有1M的页面

![1593714462174](../img/1593714462174.png)

![1593714474674](../img/1593714474674.png)

地址映射

![1593714539051](../img/1593714539051.png)

![1593714691003](../img/1593714691003.png)

![1593714739739](../img/1593714739739.png)

逻辑上连续的页被离散的分配在物理内存上
![1593714768701](../img/1593714768701.png)

#### 页映射

![1593714846019](../img/1593714846019.png)



![1593715091988](../img/1593715091988.png)

![1593715229675](../img/1593715229675.png)

![1593715241963](../img/1593715241963.png)

![1593715294451](../img/1593715294451.png)



分页式存储管理中，地址转换工作是由（ 硬件）完成的

![1593715523867](../img/1593715523867.png)

页面长度固定并且是硬件的设计特性

#### 页信息保护

![1593715659741](../img/1593715659741.png)

![1593715680109](../img/1593715680109.png)

![1593715704403](../img/1593715704403.png)




#### 快表&TLB



![1593715777723](../img/1593715777723.png)

![1593715745913](../img/1593715745913.png)

![1593715855250](../img/1593715855250.png)

![1593715897813](../img/1593715897813.png)

![1593715908011](../img/1593715908011.png)

![1593715921642](../img/1593715921642.png)

多级页表
![1593715945155](../img/1593715945155.png)

![1593715984405](../img/1593715984405.png)

二级

![1593716021283](../img/1593716021283.png)

![1593716032179](../img/1593716032179.png)

页地址映射过程中，内存越界保护的判断方法是将访问的逻辑地址的页号与（   页表长度寄存器   ）比较。

在页式存储管理方案下，为了加快地址映射速度引入了                        。

第一空： 

快表；TLB；转换检测缓冲

### 分段技术

![1593716196509](../img/1593716196509.png)

![1593716205689](../img/1593716205689.png)

![1593716213876](../img/1593716213876.png)

![1593716228890](../img/1593716228890.png)



![1593716266386](../img/1593716266386.png)



![1593716284811](../img/1593716284811.png)

![1593716301971](../img/1593716301971.png)

#### 段表

![1593716329530](../img/1593716329530.png)

![1593716359224](../img/1593716359224.png)

![1593716387674](../img/1593716387674.png)



![1593716410912](../img/1593716410912.png)

![1593716483114](../img/1593716483114.png)

#### 分页与分段差别

![1593716501985](../img/1593716501985.png)

#### 特点

逻辑地址不连续的

页地址是一维，段地址是二维
分页是操作系统进行的，分段是用户确定的
各页可以分散存放在主存，每段必须占用连续的主存空间

### 段页式

![1593717014458](../img/1593717014458.png)

![1593717043556](../img/1593717043556.png)

![1593717086315](../img/1593717086315.png)

![1593717149300](../img/1593717149300.png)

### 逻辑扩充内存

![1593717232130](../img/1593717232130.png)

![1593717251126](../img/1593717251126.png)

![1593717269459](../img/1593717269459.png)

#### SWAP交换

![1593717308130](../img/1593717308130.png)

![1593717339002](../img/1593717339002.png)

![1593717389483](../img/1593717389483.png)

![1593717415001](../img/1593717415001.png)

#### 虚拟存储

![1593717495573](../img/1593717495573.png)

![1593717510947](../img/1593717510947.png)

![1593717527849](../img/1593717527849.png)

![1593717572306](../img/1593717572306.png)

区别

对换是将暂时不需要的移到外存

而虚拟存储是部分程序

### 请求分页技术

![1593717749364](../img/1593717749364.png)

![1593717759915](../img/1593717759915.png)

![1593717784661](../img/1593717784661.png)

![1593717795811](../img/1593717795811.png)

![1593717816878](../img/1593717816878.png)

![1593717826701](../img/1593717826701.png)

![1593717852893](../img/1593717852893.png)

#### 中断区别

中断是程序不连续

![1593717894898](../img/1593717894898.png)

产生六次缺页中断

![1593717976141](../img/1593717976141.png)

![1593718020754](../img/1593718020754.png)

---

---

调入页面来源

![1593718113754](../img/1593718113754.png)

![1593718139780](../img/1593718139780.png)

分配策略

![1593718156890](../img/1593718156890.png)

![1593718174802](../img/1593718174802.png)

![1593718204882](../img/1593718204882.png)

![1593718217621](../img/1593718217621.png)

#### 分配策略

![1593718367217](../img/1593718367217.png)

请求分页存储管理中，若把页面尺寸增加一倍，在程序顺序执行时，则一般缺页中断次数会（减少）。

### 请求分页之页面置换算法

## IO系统

### 设备管理

![1593718734394](../img/1593718734394.png)

![1593718767570](../img/1593718767570.png)

![1593718790041](../img/1593718790041.png)

![1593718849123](../img/1593718849123.png)

![1593718873363](../img/1593718873363.png)

![1593718898329](../img/1593718898329.png)

![1593718949651](../img/1593718949651.png)

![1593718998882](../img/1593718998882.png)

#### I/O系统模型

![1593719036178](../img/1593719036178.png)

#### 设备分类

![1593719306544](../img/1593719306544.png)

![1593719317737](../img/1593719317737.png)

![1593719330388](../img/1593719330388.png)

![1593719342164](../img/1593719342164.png)

![1593719351208](../img/1593719351208.png)

####　设备控制器
![1593719369538](../img/1593719369538.png)

![1593719405834](../img/1593719405834.png)

![1593719427980](../img/1593719427980.png)

![1593719494235](../img/1593719494235.png)

![1593719510338](../img/1593719510338.png)

通道用于内存与外设的信息传输

#### 中断处理

![1593719654305](../img/1593719654305.png)

![1593719668922](../img/1593719668922.png)

![1593719789233](../img/1593719789233.png)

![1593719815664](../img/1593719815664.png)

为不同的设备规定不同的优先级

![1593719866696](../img/1593719866696.png)

![1593719886880](../img/1593719886880.png)

![1593719975133](../img/1593719975133.png)

![1593720209992](../img/1593720209992.png)

![1593720249075](../img/1593720249075.png)

![1593720280296](../img/1593720280296.png)

![1593720288402](../img/1593720288402.png)

算机系统中判别是否有中断事件发生应是在(执行完一条指令后      )



当用户程序执行访管指令时，中断装置将使中央处理器（    从目态转换到管态）工作。

各类中断中，优先级高的三个中断应是（     ）。

- A、硬件故障 B、程序 C、外部 D、I/OE、访管

正确答案： ACD 我的答案：ACD

#### DMA

[DMA](https://baike.baidu.com/item/DMA/2385376)（Direct Memory Access）控制器是一种在系统内部转移数据的独特外设，可以将其视为一种能够通过一组专用总线将内部和外部存储器与每个具有DMA能力的外设连接起来的控制器。它之所以属于外设，是因为它是在处理器的编程控制下来 **执行传输的**

#### 设备驱动程序

中央处理器启动通道工作时，通过通道程序执行通道命令，这时第一条通道命令是由( CAW　）来指示的。

启动外设前必须组织好通道程序，通道程序是由若干(    CCW  )组成

通常把通道程序的执行情况记录在（   CSW）中

硬件采用了中断和通道技术，使得（ CPU 与外设能并行工作    ） 。

DMA控制方式相比中断控制方式，大大降低了中断次数，简化了中断处理工作。

![1593720926304](../img/1593720926304.png)

![1593720949467](../img/1593720949467.png)

![1593720973288](../img/1593720973288.png)

![1593721017441](../img/1593721017441.png)

#### 设备独立性与分配

为了实现设备的独立性，操作系统让用户使用（　逻辑设备名　）。

设备管理的主要程序之一是设备分配程序，当进程请求在内存和外设之间传送信息时，设备分配程序分配设备的过程通常是（  先分配设备，再分配控制器，最后分配通道  ）

![1593721180584](../img/1593721180584.png)

![1593721232514](../img/1593721232514.png)

![1593721241424](../img/1593721241424.png)

![1593721259764](../img/1593721259764.png)

![1593721271967](../img/1593721271967.png)

![1593721281087](../img/1593721281087.png)

![1593721295264](../img/1593721295264.png)

#### 缓冲技术

引入缓冲技术的主要目的是(提高CPU与设备之间的并行程度    )。

CPU输出数据的速度远远高于打印机的打印速度，为了解决这一矛盾，可采用（缓冲技术    ）。

【单选题】

操作系统采用缓冲技术，能够减少对CPU的（   中断 ）次数，从而提高资源的利用率。

软件缓冲技术包括（ 单缓冲技术 双缓冲技术 循环缓冲   缓冲池）

#### 用户IO层软件

![1593721477832](../img/1593721477832.png)

![1593721514825](../img/1593721514825.png)

![1593721527919](../img/1593721527919.png)

![1593721541345](../img/1593721541345.png)

![1593721552517](../img/1593721552517.png)

![1593721562040](../img/1593721562040.png)

![1593721584172](../img/1593721584172.png)

![1593721595416](../img/1593721595416.png)

![1593721605450](../img/1593721605450.png)

并没有为程序分配设备，而是将输出写u人磁盘物理块

采用假脱机技术的目的是（   提高外设和主机的利用率  ）。

Spool 技术是一种实现虚拟（设备   ）的技术。

（ 通道   ）程序不是spool 系统的组成部分

## 磁盘管理

#### 磁盘组成
![1593721851278](../img/1593721851278.png)

![1593721879158](../img/1593721879158.png)

![1593721930337](../img/1593721930337.png)

![1593721974240](../img/1593721974240.png)

![1593721985671](../img/1593721985671.png)

![1593722009879](../img/1593722009879.png)

![1593722046633](../img/1593722046633.png)

![1593722101093](../img/1593722101093.png)

![1593722152038](../img/1593722152038.png)

![1593722354408](../img/1593722354408.png)

![1593722370231](../img/1593722370231.png)

![1593722469711](../img/1593722469711.png)

#### 磁盘调度

![1593722583678](../img/1593722583678.png)

![1593722630358](../img/1593722630358.png)

![1593722645183](../img/1593722645183.png)

![1593722653942](../img/1593722653942.png)

![1593722684399](../img/1593722684399.png)

![1593722764559](../img/1593722764559.png)

![1593722852406](../img/1593722852406.png)

![1593723009264](../img/1593723009264.png)

![1593723078551](../img/1593723078551.png)

![1593723050190](../img/1593723050190.png)

![1593723087813](../img/1593723087813.png)

![1593723102486](../img/1593723102486.png)

## 文件系统

![1593723165434](../img/1593723165434.png)

![1593723176694](../img/1593723176694.png)



分类

![1593723243096](../img/1593723243096.png)

![1593723254511](../img/1593723254511.png)

![1593723264951](../img/1593723264951.png)

![1593723326224](../img/1593723326224.png)

![1593723335654](../img/1593723335654.png)

![1593723346085](../img/1593723346085.png)

文件系统与（存储管理   ）密切相关，它们共同为用户使用文件提供方便

特别文件是与（   硬件设备 ）有关的文件

文件系统是指（  ）。文件、管理文件的软件及数据结构的总体



#### 文件逻辑结构

![1593723514735](../img/1593723514735.png)

![1593723564341](../img/1593723564341.png)

![1593723578693](../img/1593723578693.png)

![1593723593006](../img/1593723593006.png)

![1593723614414](../img/1593723614414.png)

![1593723629846](../img/1593723629846.png)

![1593723643165](../img/1593723643165.png)

![1593723649114](../img/1593723649114.png)

![1593723654844](../img/1593723654844.png)

#### 存取方法

![1593723674719](../img/1593723674719.png)

![1593723707889](../img/1593723707889.png)

![1593723712728](../img/1593723712728.png)

![1593723721608](../img/1593723721608.png)

![1593723730614](../img/1593723730614.png)

![1593723742526](../img/1593723742526.png)

![1593723765599](../img/1593723765599.png)

   从用户观点看 ）的文件组织形式称为文件的逻辑组织

UNIX系统中，采用的文件逻辑结构是（　流式文件　　）。

#### 文件物理结构

![1593723895644](../img/1593723895644.png)

![1593723903861](../img/1593723903861.png)

![1593723936541](../img/1593723936541.png)

![1593723943255](../img/1593723943255.png)

![1593723948887](../img/1593723948887.png)

![1593723956262](../img/1593723956262.png)

![1593723974381](../img/1593723974381.png)

![1593723982719](../img/1593723982719.png)

![1593723992342](../img/1593723992342.png)

![1593724000422](../img/1593724000422.png)

![1593724042220](../img/1593724042220.png)

![1593724049565](../img/1593724049565.png)

逻辑文件存放在到存储介质上时，采用的组织形式是与(    存储介质特性  )有关的。

索引式（随机）文件组织的一个主要优点是（ 能实现物理块的动态分配 ）

### 目录管理

![1593724137768](../img/1593724137768.png)

![1593724147231](../img/1593724147231.png)

![1593724195063](../img/1593724195063.png)

![1593724204582](../img/1593724204582.png)

![1593724215189](../img/1593724215189.png)

![1593724225580](../img/1593724225580.png)

![1593724234782](../img/1593724234782.png)

![1593724247621](../img/1593724247621.png)

![1593724283598](../img/1593724283598.png)

![1593724293110](../img/1593724293110.png)

![1593724300798](../img/1593724300798.png)

![1593724312191](../img/1593724312191.png)

![1593724323662](../img/1593724323662.png)

![1593724342702](../img/1593724342702.png)

![1593724362397](../img/1593724362397.png)

![1593724380133](../img/1593724380133.png)

![1593724451343](../img/1593724451343.png)

![1593724523911](../img/1593724523911.png)

文件的存储空间管理实质上是对（ 外存空白块  ）的组织和管理的问题。

位示图法使用一个向量描述整个磁盘，向量的每一位表示一个（   物理块    ）的状态，用0或1表示该块的使用与否。

unix的磁盘空间管理方法是成组链接法。

当CPU执行操作系统代码时，称处理机处于（   A、

管态

单任务操作系统不需要进行进程上下文切换
															                                                                    	                                							    <!-- 第三级级开始  -->
																			                            									<!-- 第三级结束  -->
						                