```asm
**************************************************************************************************
;进行base64编码的函数
;参数：_lpszInput 指向输入缓冲区  _lpszOtput 指向输出缓冲区  _dwInputLen 想要加密的长度
;返回值：成功返回0  失败返回 -1
;作者：zklhp  Email:zklhp@sina.com
;时间：2008.8.9
;版权所有    转载请保持完整
;**************************************************************************************************

_base64 proc uses ebx esi edi _lpszInput:DWORD,_dwInputLen:DWORD,_lpszOtput:DWORD

;错误处理
    .if (_lpszInput==NULL)||(_lpszOtput==NULL)||(_dwInputLen==0)
        xor eax,eax
        dec eax
        ret
    .endif

    mov eax,_dwInputLen
    xor edx,edx
    mov ecx,3
    div ecx
    push eax
    
    .if eax > 0
        dec eax
        .if eax > 0
            push eax

            push ebp
            mov esi,_lpszInput
            mov edi,_lpszOtput
            mov ebp,eax
            lea edi,[edi+ebp*4]
            neg ebp

            align 4
        @@:

            mov ebx,DWORD ptr [esi]
            bswap ebx
            mov ecx,ebx
            mov edx,ebx
            mov eax,ebx
            shr ecx,14
            shr edx,8
            shr eax,26
            and ecx,3Fh
            shr ebx,20
            and edx,3Fh
            and eax,3Fh
            movzx ecx, BYTE PTR [base64_alphabet+ecx]
            and ebx,3Fh
            mov ch , BYTE PTR [base64_alphabet+edx]
            movzx eax, BYTE PTR [base64_alphabet+eax]
            shl ecx,16
            mov ah,BYTE PTR [base64_alphabet+ebx]
                
            add esi,3
            or ecx,eax
            mov [edi+ebp*4],ecx

            add ebp,1
            jnz @B
            pop ebp

            pop eax
            mov ecx,eax
            mov ebx,3
            mul ebx
            add _lpszInput,eax
            shl ecx,2
            add _lpszOtput,ecx
        .endif

        mov esi,_lpszInput
        mov edi,_lpszOtput
        mov ebx,DWORD ptr [esi]
        bswap ebx
        mov ecx,ebx
        mov edx,ebx
        mov eax,ebx
        shr ecx,14
        shr edx,8
        shr eax,26
        and ecx,3Fh
        shr ebx,20
        and edx,3Fh
        and eax,3Fh
        movzx ecx, BYTE PTR [base64_alphabet+ecx]
        and ebx,3Fh
        mov ch , BYTE PTR [base64_alphabet+edx]
        movzx eax, BYTE PTR [base64_alphabet+eax]
        shl ecx,16
        mov ah,BYTE PTR [base64_alphabet+ebx]         
        or ecx,eax
        mov [edi],ecx
        add _lpszInput,3
        add _lpszOtput,4
    .endif
    pop eax
    mov ecx,3
    mul ecx
    neg eax
    add eax,_dwInputLen
    ;int 3h
    .if eax == 1
        mov esi,_lpszInput
        mov edi,_lpszOtput
        movzx ecx,BYTE ptr [esi]
        mov ebx,ecx
        mov edx,ecx
        shr ecx,2
        movzx ecx,BYTE ptr [base64_alphabet+ecx]
        shl edx,4
        and edx,03fh
        movzx edx,[base64_alphabet+edx]
        shl edx,8
        or ecx,edx
        xor ebx,ebx
        mov bl,'='
        mov bh,'='
        shl ebx,16
        or ecx,ebx
        mov [edi],ecx
    .elseif eax == 2
        push eax
        mov esi,_lpszInput
        mov edi,_lpszOtput
        movzx ecx,BYTE ptr [esi]
        shr ecx,2
        movzx ecx,BYTE ptr [base64_alphabet+ecx]
        movzx eax,BYTE ptr [esi+1]
        shr eax,4
        movzx ebx,BYTE ptr [esi]
        shl ebx,4
        or ebx,eax
        and ebx,03fh
        movzx ebx,BYTE ptr [base64_alphabet+ebx]
        movzx eax,BYTE ptr [esi+1]
        shl eax,2
        and eax,03fh
        movzx eax,BYTE ptr [base64_alphabet+eax]
        xor edx,edx
        mov dh,'='
        shl edx,16
        or ecx,edx
        shl ebx,8
        or ecx,ebx
        shl eax,16
        or ecx,eax
        mov [edi],ecx
        pop eax
    .endif

    xor eax,eax
    ret
_base64 endp

```

